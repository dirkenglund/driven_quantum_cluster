# -*- coding: utf-8 -*-
"""20241217.cluster state simulation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1c431CK6v4wbLeaIVFY0haQKMogO6i6Xi
"""

# -*- coding: utf-8 -*-
"""
Quantum Percolation Visualization on a Square Lattice

Improvements over previous version:
- Modularized functions
- Added docstrings and inline comments
- Enhanced parameter validations
- Precomputed positions and reused them
- Optionally set a random seed for reproducible runs
"""

import networkx as nx
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation, PillowWriter
from IPython.display import Image
import io
import tempfile
import os
import random
import matplotlib.lines as mlines
import ipywidgets as widgets

def create_empty_graph(n):
    """
    Creates an empty n x n lattice graph with no edges.

    Parameters
    ----------
    n : int
        Number of nodes along each dimension.

    Returns
    -------
    G : networkx.Graph
        Graph with nodes placed in an n x n grid.
    """
    G = nx.Graph()
    for x in range(n):
        for y in range(n):
            G.add_node((x, y))
    return G

def attempt_add_edges(G, step, n, p_trial, trial_array):
    """
    Attempt to add edges between nodes according to the given probabilities and pattern.

    Parameters
    ----------
    G : networkx.Graph
        The current graph.
    step : int
        Current simulation step.
    n : int
        Lattice size.
    p_trial : float
        Probability of establishing entanglement.
    trial_array : np.ndarray
        Precomputed random array for edge trials: shape (n, n, steps).

    Notes
    -----
    Edges are attempted in a pattern depending on step % 4 to simulate directional attempts.
    """
    mod_step = step % 4
    for x in range(n):
        for y in range(n - 1):
            current_p = trial_array[x, y, step]
            # Only attempt adding if below threshold
            if current_p < p_trial:
                if mod_step == 0 and x % 2 == 0 and y % 2 == 0:
                    # Horizontal links on even rows at even columns
                    G.add_edge((x, y), (x, y + 1))
                elif mod_step == 1 and x % 2 == 0 and x < n - 1:
                    # Vertical links from even row to next row
                    G.add_edge((x, y), (x + 1, y))
                elif mod_step == 2 and x % 2 == 1 and y % 2 == 1:
                    # Horizontal links on odd rows at odd columns
                    G.add_edge((x, y), (x, y + 1))
                elif mod_step == 3 and x % 2 == 1 and x < n - 1:
                    # Vertical links from odd row to next row
                    G.add_edge((x, y), (x + 1, y))

def introduce_errors(G, largest_cc, error_array, step, p_error, error_edges):
    """
    Introduce heralded entanglement/decoherence errors at each step.

    Parameters
    ----------
    G : networkx.Graph
        Current state of the graph.
    largest_cc : set
        Largest connected component at this step.
    error_array : np.ndarray
        Array of random values for error introduction.
    step : int
        Current simulation step.
    p_error : float
        Probability of heralded entanglement/decoherence error.
    error_edges : set
        Set to store edges that experience heralded errors.

    Notes
    -----
    For each node, if an error occurs, remove its edges. If these edges were part of the largest CC,
    mark them as error edges.
    """
    # Copy node list to avoid changing dict during iteration
    for node in list(G.nodes):
        # Map node[0] to a unique index, for variety we just mod by n but could do different indexing
        if error_array[node[0] % len(error_array), step] < p_error:
            neighbors = list(G.neighbors(node))
            for neighbor in neighbors:
                if node in largest_cc and neighbor in largest_cc:
                    error_edges.add(tuple(sorted((node, neighbor))))
                G.remove_edge(node, neighbor)

def draw_grid(step, G, largest_cc, n, ax, error_edges, pos):
    """
    Draw the square lattice graph with color-coded nodes and edges.

    Parameters
    ----------
    step : int
        Current simulation step.
    G : networkx.Graph
        Current state of the graph.
    largest_cc : set
        Largest connected component in the graph.
    n : int
        Lattice size.
    ax : matplotlib.axes.Axes
        Axes object for plotting.
    error_edges : set
        Set of edges with heralded entanglement or decoherence errors.
    pos : dict
        Precomputed positions of nodes.
    """
    ax.clear()

    # Determine node colors
    node_colors = ['red' if node in largest_cc else 'gray' for node in G.nodes]

    edge_colors = []
    edge_styles = []
    for u, v in G.edges:
        edge_tuple = tuple(sorted((u, v)))
        if edge_tuple in error_edges:
            # Error edges are dashed red
            edge_colors.append('red')
            edge_styles.append('dashed')
        elif u in largest_cc and v in largest_cc:
            # Edges in largest CC are solid red
            edge_colors.append('red')
            edge_styles.append('solid')
        else:
            # Regular edges are solid black
            edge_colors.append('black')
            edge_styles.append('solid')

    nx.draw(G, pos, node_color=node_colors, edge_color=edge_colors, style=edge_styles,
            with_labels=False, node_size=80, font_weight='bold', ax=ax)

    # Add legend
    data_qubit_marker = mlines.Line2D([], [], color='grey', marker='o', markersize=10,
                                      label='Data Qubit', linestyle='None')
    data_qubit_largest_marker = mlines.Line2D([], [], color='red', marker='o', markersize=10,
                                              label='Data Qubit in Largest Cluster', linestyle='None')
    entanglement_line = mlines.Line2D([], [], color='black', linestyle='-', linewidth=2,
                                      label='Entanglement')
    entangled_cluster_line = mlines.Line2D([], [], color='red', linestyle='-', linewidth=2,
                                           label='Largest Entangled Cluster')
    heralded_error_line = mlines.Line2D([], [], color='red', linestyle='dashed', linewidth=2,
                                        label='Heralded Error')

    ax.legend(handles=[data_qubit_marker, data_qubit_largest_marker, entanglement_line,
                       entangled_cluster_line, heralded_error_line], loc='upper right')

    ax.set_title(f"Time step: {step+1}")

def percolation_simulation(n, steps, p_trial, p_error, seed=42):
    """
    Simulates quantum percolation on a square lattice over a specified number of steps.

    Parameters
    ----------
    n : int
        Size of the lattice (n x n).
    steps : int
        Number of simulation steps.
    p_trial : float
        Probability of establishing entanglement.
    p_error : float
        Probability of heralded entanglement/decoherence error.
    seed : int, optional
        Random seed for reproducibility.

    Yields
    ------
    step : int
        Current simulation step.
    G : networkx.Graph
        Current state of the graph.
    largest_cc : set
        Largest connected component in the graph.
    error_edges : set
        Set of edges with heralded entanglement or decoherence errors.

    Notes
    -----
    This function uses a simple heuristic to place edges depending on step % 4.
    """
    # Validate parameters
    assert 0.0 <= p_trial <= 1.0, "p_trial must be between 0 and 1."
    assert 0.0 <= p_error <= 1.0, "p_error must be between 0 and 1."
    assert n > 0, "n must be positive."
    assert steps > 0, "steps must be positive."

    np.random.seed(seed)

    G = create_empty_graph(n)
    error_edges = set()
    largest_cc = set()

    # Precompute random trials for edges and errors
    trial_array = np.random.rand(n, n, steps)
    # Make shape dependent on n and steps. You could tweak this if you want a different scheme.
    error_array = np.random.rand(n, steps)

    # Precompute connected components every step
    for step in range(steps):
        # Attempt to add edges based on trial probability
        attempt_add_edges(G, step, n, p_trial, trial_array)

        # Find largest connected component
        connected_components = nx.connected_components(G)
        largest_cc = max(connected_components, key=len) if G.edges else set()

        # Introduce heralded errors
        introduce_errors(G, largest_cc, error_array, step, p_error, error_edges)

        # Recompute largest CC after errors
        if G.edges:
            connected_components = nx.connected_components(G)
            largest_cc = max(connected_components, key=len)
        else:
            largest_cc = set()

        yield step, G, largest_cc, error_edges

# Simulation parameters
n = 20        # Size of the lattice (n x n)
steps = 80    # Number of time steps
p_trial = 0.1 # Probability of establishing entanglement
p_error = 0.01 # Probability of error

# Precompute positions once for all steps
pos = {(x, y): (x, y) for x in range(n) for y in range(n)}

# Create figure for animation
fig, ax = plt.subplots(figsize=(6, 6))

def update(frame):
    """
    Update function for matplotlib FuncAnimation.
    """
    step, G, largest_cc, error_edges = frame
    draw_grid(step, G, largest_cc, n, ax, error_edges, pos)

ani = FuncAnimation(fig, update, frames=percolation_simulation(n, steps, p_trial, p_error),
                    blit=False, interval=500, repeat=False, save_count=steps)
plt.close(fig)  # Prevents intermediate plot display



# Save the animation as a GIF.
gif_writer = PillowWriter(fps=2)
with tempfile.NamedTemporaryFile(delete=False, suffix=".gif") as tmpfile:
    ani.save(tmpfile.name, writer=gif_writer)
    tmpfile.seek(0)
    buf = io.BytesIO(tmpfile.read())

os.unlink(tmpfile.name)

# Display the GIF in a Jupyter environment
Image(buf.getvalue())

ax.set_aspect('equal', adjustable='box')
ax.set_xlim(-1, n)
ax.set_ylim(-1, n)


pos = {(x, y): (x, y) for x in range(n) for y in range(n)}

ax.autoscale(False)

